---
title: Yield Fee
order: 7
---
# Introduction
Yield fees are a mechanism that allows Balancer to harness a portion of the yield generated by the liquidity provided. For instance, if a liquidity provider contributes wrapped staked Ether (wstETH) to a pool and this token increases in value due to yield growth, a yield fee is applied to a fraction of that growth and reinvested into the Balancer ecosystem to contribute to the overall health and growth of the ecosystem.

# Yield fee. 
On every state changing vault interaction a yield fee is charged, depending on a token's specific configuration. This fee is paid by liquidity providers depending on the token's exemption status in the [`TokenConfig`](https://github.com/balancer/balancer-v3-monorepo/blob/main/pkg/interfaces/contracts/vault/VaultTypes.sol#L73) as the token that has accrued yield. The `yieldFeePercentage` parameter, which is controlled by the protocol, sets the fee's percentage. It's important to note that this percentage is consistent across all pools.

## Importance for the Balancer protocol
The application of the yield fee serves three primary purposes that make it an excellent fit for the Balancer protocol:
- 1. A portion of the yield fees contributes to the operational costs of the Balancer DAO and acts as a source of revenue for the protocol.
- 2. Yield fees are partially recycled and used as liquidity incentives on stakers of certain pools deemed [core-pools](https://forum.balancer.fi/t/bip-19-incentivize-core-pools-l2-usage/3329) based on the current [gauge-framework](https://forum.balancer.fi/t/bip-57-introduce-gauge-framework-v1/3604).
- 3. A portion of the yield fees generated is distributed to veBAL holders.

TODO: verify expected yield fee percentage.

This mechanism is used to bootstrap liquidity and maintain deep liquidity for tokens on Balancer to facilitate low slippage for sizeable trades.

## Implementation
The implementation of yield fees utilizes a Balancer internal concept called [live balances](./token-scaling.md#live-balances). Yield fees are computed by taking the difference in `currentLiveBalance` and `lastLiveBalance` and multiplying it by the `yieldFeePercentage`. Fees only get charged if yield has accrued.
```solidity
function _computeYieldProtocolFeesDue(
    PoolData memory poolData,
    uint256 lastLiveBalance,
    uint256 tokenIndex,
    uint256 yieldFeePercentage
) internal pure returns (uint256 feeAmountRaw) {
    uint256 currentLiveBalance = poolData.balancesLiveScaled18[tokenIndex];

    // Do not charge fees if rates go down. If the rate were to go up, down, and back up again, protocol fees
    // would be charged multiple times on the "same" yield. For tokens subject to yield fees, this should not
    // happen, or at least be very rare. It can be addressed for known volatile rates by setting the yield fee
    // exempt flag on registration, or compensated off-chain if there is an incident with a normally
    // well-behaved rate provider.
    if (currentLiveBalance > lastLiveBalance) {
        unchecked {
            // Magnitudes checked above, so it's safe to do unchecked math here.
            uint256 liveBalanceDiff = currentLiveBalance - lastLiveBalance;

            feeAmountRaw = liveBalanceDiff.mulDown(yieldFeePercentage).toRawUndoRateRoundDown(
                poolData.decimalScalingFactors[tokenIndex],
                poolData.tokenRates[tokenIndex]
            );
        }
    }
}
```
The `feeAmountRaw` represents the final computed yield fee value. Here, 'Raw' signifies that the [rate scaling](./token-scaling.md#rate-scaling) has been reversed, as indicated by the `toRawUndoRateRoundDown` expression.

:::info
to check if a token in a liquidity pool is subject to yield fees, you need to listen to the `PoolCreated` event of the pool creation transaction. The percentage of yield fees charged by the vault can be read via `vault.getYieldFeePercentage()`. 
:::

