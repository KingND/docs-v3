---
title: Architecture
order: 30
---

# Architecture

The Balancer protocol architecture is based on three main components, which serve a unique purpose in making Balancer flexible while drastically reducing complexity of pool code. Each liquidity pool is a separate contract but token balances are tracked at the Vault level. 

- Router: Entrypoint for user operations with simple interfaces
- Vault: Handle liquidity operations and accounting
- Pool: Expose pool math via invariant calculations

## Overview
The diagram shows the core components that make up Balancer Protocol and the transaction flow through the primary system components.

![Router Vault interaction](/images/architecture-1.png)

1. The [Router](/concepts/router/technical.html) acts as the primary interface for accessing the Balancer protocol, offering a user-friendly way to interact with the Balancer Vault.

2. The Router establishes a TAB with the [Vault](/concepts/vault), which records all credits and debits generated by operations like adding liquidity, removing liquidity, and swaps.

3. In the case of a swap, the pool's invariant, which is defined in the pool contract, determines the quantity of tokens being either deposited (`EXACT_OUT` swap) in the Vault or withdrawn (`EXACT_IN` swap) from the Vault.

4. Once the required token amounts have been calculated, these amounts are recorded as either credit or debt in the Vault.

5. To maintain accurate accounting and ensure the Vault's token balances align with it's internal accounting, the Router's accrued credit and/or debt must be settled by the end the transaction.

6. In the final step, the Vault verifies that the Router has correctly settled its accrued debts and credits. The transaction will only succeed if everything has been accurately settled; otherwise, it will be reverted.

## Detailed overview

![Detailed Router Vault interaction](/images/architecture-2.png)

1. The Balancer Router is the main interface for interacting with Balancer, providing a user-friendly way to access functions and simplify interactions with the Vault. Any smart contract can serve as a Router, tailored to the specific use case.

2. The Router calls the Vault's `lock` method and is added to a list of `_lockers`. These lockers are assigned either debt or credit as part of the ongoing transaction with the intention to allow operations on the Vault to be combined atomically and still ensure correct accounting.

3. With the lock open, the Vault calls back into the Router. For example, in the case of a swap action, the Vault calls the Router's specific action hook implementation, such as `swapSingleTokenHook`, and passes the initial function payload from step 1 back to the Router to continue the regular transaction flow.

4. Once the Router has established a lock with the Vault, it gains authorization to invoke the Vault's functions that require the caller' to be in the _lockers list. This mechanism guarantees the accurate allocation of debt and credit. The inputs from step 1 are passed to the Vault's core functions, such as swap.

5. Each primitive operation performed on the Vault triggers the execution of either the `computeInvariant` or `computeBalance` functions in the pool. These functions calculate the tokens that need to be deposited into or withdrawn from the Vault. The outcomes of these calculations are attributed to the Router as either debt or credit, which must be settled at a later stage. Additionally, the required amount of Balancer Pool Tokens (BPT) is minted or burned accordingly.

6. Pools offer a range of hook capabilities that can be leveraged at different stages of the pool's lifecycle. These hooks can be executed either before or after a pool operation, depending on how the pool is configured during deployment. By utilizing hooks, developers can customize and enhance the functionality of pools, enabling the integration of features like oracles or time-weighted average market maker capabilities.      

- 4(*) After debt & credit has been recorded for and shared with the Router by the Vault, the execution flow is passed to the Router. This allows the Router to be aware of the amounts owed. It is important to mention that the Router contract has the ability to retrieve the current debt and credit owed to the Vault at any point during the execution by calling a specific function on the Vault.

7. The Router is responsible for settling the remaining debt and credit, which must be done for the transaction to succeed. If ETH or WETH is to be used in the transaction, the Router wraps or unwraps Ether as the final step.

8. The final step involves verifying that all credit and debt accrued during the operation has been settled for each `_locker`. Once the verification is complete, the lock is closed. If all debt has been correctly settled, the transaction will succeed; otherwise, it will be reverted..
